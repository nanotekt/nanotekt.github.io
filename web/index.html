<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>nanore</title>
<meta property="og:title" content="nanore">
<meta property="og:description" content="CPU raytracer in the browser">
<meta property="og:image" content="__OG_IMAGE_URL__">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="nanore">
<meta name="twitter:description" content="CPU raytracer in the browser">
<meta name="twitter:image" content="__OG_IMAGE_URL__">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;background:#0d0d1a;color:#c0c0d0;font-family:'Courier New',monospace;overflow:hidden}
#app{display:flex;height:100vh}
#render-panel{flex:1;display:flex;flex-direction:column;padding:12px;min-width:0}
#tab-bar{display:flex;gap:4px;margin-bottom:8px}
.tab{padding:6px 18px;background:#1a1a2e;border:1px solid #333;color:#777;cursor:pointer;font-family:inherit;font-size:13px;transition:all .15s}
.tab:hover{color:#aaa;border-color:#555}
.tab.active{background:#2a1a3e;color:#e0a0d0;border-color:#6a3a7a}
#canvas-wrap{position:relative;flex:1;display:flex;align-items:center;justify-content:center;background:#080810;border:1px solid #222;border-radius:4px;overflow:hidden}
canvas{max-width:100%;max-height:100%;image-rendering:auto}
#overlay{position:absolute;inset:0;display:none;flex-direction:column;align-items:center;justify-content:center;background:rgba(8,8,16,0.3);backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);z-index:10}
#progress-track{width:50%;height:4px;background:#1a1a2e;border-radius:2px;overflow:hidden}
#progress-fill{height:100%;width:0%;background:linear-gradient(90deg,#e04080,#ff6090);transition:width .15s}
#progress-text{margin-top:8px;font-size:12px;color:#888}
#status{font-size:11px;color:#555;margin-top:6px;height:14px}
#editor-panel{width:440px;display:flex;flex-direction:column;border-left:1px solid #222}
#editor-header{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:#111;border-bottom:1px solid #222}
#editor-header span{font-size:13px;color:#888}
#render-btn{padding:5px 14px;background:#e04080;color:#fff;border:none;cursor:pointer;font-family:inherit;font-size:12px;border-radius:3px;transition:background .15s}
#render-btn:hover{background:#ff5090}
#render-btn:disabled{background:#555;cursor:default}
#yaml-editor{flex:1;padding:12px;background:#0a0a14;color:#b0b0c0;border:none;resize:none;font-family:'Courier New',monospace;font-size:12px;line-height:1.5;tab-size:2;outline:none;white-space:pre;overflow-wrap:normal;overflow-x:auto}
#yaml-editor::selection{background:#3a2a5a}
#error-bar{display:none;padding:6px 12px;background:#3a1020;color:#ff6080;font-size:12px;border-bottom:1px solid #552040}
</style>
</head>
<body>
<div id="app">
  <div id="render-panel">
    <div id="tab-bar">
      <button class="tab active" data-tab="color">Color</button>
      <button class="tab" data-tab="zbuffer">Z-buffer</button>
    </div>
    <div id="canvas-wrap">
      <canvas id="render-canvas" width="256" height="256"></canvas>
      <div id="overlay">
        <div id="progress-track"><div id="progress-fill"></div></div>
        <div id="progress-text">0%</div>
      </div>
    </div>
    <div id="status">Loading WASM...</div>
  </div>
  <div id="editor-panel">
    <div id="editor-header">
      <span>Scene YAML</span>
      <button id="render-btn">Render</button>
    </div>
    <div id="error-bar"></div>
    <textarea id="yaml-editor" spellcheck="false">__DEFAULT_YAML__</textarea>
  </div>
</div>

<script src="coi-serviceworker.js"></script>
<script>
// Module config MUST be set before nanore.js loads
var Module = {
  print: function(text) { console.log('[nanore]', text); },
  printErr: function(text) { console.warn('[nanore]', text); },
  onRuntimeInitialized: function() {
    console.log('[nanore] Runtime initialized');
    document.getElementById('status').textContent = 'Ready — starting render...';
    // Delay to let pthread pool workers finish loading
    setTimeout(function() { window._nanoreReady = true; window._nanoreStart(); }, 500);
  }
};
</script>
<script src="nanore.js"></script>
<script>
(function() {
  var canvas = document.getElementById('render-canvas');
  var ctx = canvas.getContext('2d');
  var editor = document.getElementById('yaml-editor');
  var overlay = document.getElementById('overlay');
  var progressFill = document.getElementById('progress-fill');
  var progressText = document.getElementById('progress-text');
  var statusEl = document.getElementById('status');
  var errorBar = document.getElementById('error-bar');
  var renderBtn = document.getElementById('render-btn');

  var isRendering = false;
  var activeTab = 'color';
  var debounceTimer = null;
  var pollTimer = null;
  var colorImageData = null;
  var zbufImageData = null;
  var pendingRender = false;
  var t0 = 0;

  // SharedArrayBuffer check
  if (typeof SharedArrayBuffer === 'undefined') {
    document.body.innerHTML = '<div style="padding:40px;color:#ff6080;font-family:monospace">' +
      '<h2>SharedArrayBuffer not available</h2>' +
      '<p style="margin-top:12px;color:#888">This page must be served with these HTTP headers:<br>' +
      '<code style="color:#e0a0d0">Cross-Origin-Opener-Policy: same-origin</code><br>' +
      '<code style="color:#e0a0d0">Cross-Origin-Embedder-Policy: require-corp</code></p></div>';
    return;
  }

  // Called by onRuntimeInitialized after delay
  window._nanoreStart = function() {
    console.log('[nanore] Starting initial render');
    startRender();
  };

  function startRender() {
    if (!window._nanoreReady) return;

    if (isRendering) {
      Module._cancel_render();
      pendingRender = true;
      return;
    }

    var yaml = editor.value;
    isRendering = true;
    pendingRender = false;
    renderBtn.disabled = true;
    errorBar.style.display = 'none';
    overlay.style.display = 'flex';
    progressFill.style.width = '0%';
    progressText.textContent = '0%';
    statusEl.textContent = 'Rendering...';
    t0 = performance.now();

    try {
      // Allocate YAML string in WASM memory and call start_render
      var yamlBytes = Module.lengthBytesUTF8(yaml) + 1;
      var yamlPtr = Module._malloc(yamlBytes);
      Module.stringToUTF8(yaml, yamlPtr, yamlBytes);
      Module._start_render(yamlPtr);
      Module._free(yamlPtr);
      console.log('[nanore] Render started');
    } catch (e) {
      console.error('[nanore] start_render failed:', e);
      showError('Failed to start render: ' + e.message);
      isRendering = false;
      renderBtn.disabled = false;
      overlay.style.display = 'none';
      return;
    }

    // Poll for progress and completion
    pollTimer = setInterval(pollRender, 200);
  }

  function pollRender() {
    try {
      var pct = Module._get_progress();
      progressFill.style.width = pct + '%';
      progressText.textContent = pct + '%';

      if (Module._is_render_done()) {
        clearInterval(pollTimer);
        pollTimer = null;

        var result = Module._get_render_result();
        console.log('[nanore] Render done, result=' + result);
        isRendering = false;
        renderBtn.disabled = false;
        overlay.style.display = 'none';

        if (result === 0) {
          var elapsed = ((performance.now() - t0) / 1000).toFixed(1);
          statusEl.textContent = 'Done in ' + elapsed + 's';
          captureResults();
          drawActiveTab();
        } else if (result === 1) {
          statusEl.textContent = 'Cancelled';
        } else if (result === -1) {
          showError('YAML parse error');
        } else if (result === -2) {
          showError('Version must be nanore@2');
        }

        if (pendingRender) {
          setTimeout(startRender, 100);
        }
      }
    } catch (e) {
      console.error('[nanore] Poll error:', e);
      clearInterval(pollTimer);
      pollTimer = null;
      isRendering = false;
      renderBtn.disabled = false;
      overlay.style.display = 'none';
      showError('Render error: ' + e.message);
    }
  }

  function showError(msg) {
    errorBar.textContent = msg;
    errorBar.style.display = 'block';
    statusEl.textContent = 'Error';
  }

  function getMemoryBuffer() {
    // Always get a fresh buffer reference — handles memory growth
    return Module.wasmMemory ? Module.wasmMemory.buffer : Module.HEAPU8.buffer;
  }

  function captureResults() {
    var W = Module._get_width();
    var H = Module._get_height();
    console.log('[nanore] Capturing results ' + W + 'x' + H);
    canvas.width = W;
    canvas.height = H;

    // Color buffer — use fresh view from wasmMemory to handle memory growth
    var pixPtr = Module._get_pixels_ptr();
    console.log('[nanore] pixPtr=' + pixPtr);
    if (pixPtr) {
      var buf = getMemoryBuffer();
      var pix = new Uint8Array(buf, pixPtr, W * H * 3);
      colorImageData = ctx.createImageData(W, H);
      var d = colorImageData.data;
      for (var i = 0; i < W * H; i++) {
        d[i * 4]     = pix[i * 3];
        d[i * 4 + 1] = pix[i * 3 + 1];
        d[i * 4 + 2] = pix[i * 3 + 2];
        d[i * 4 + 3] = 255;
      }
      console.log('[nanore] Color captured, first pixel: ' + d[0] + ',' + d[1] + ',' + d[2]);
    }

    // Z-buffer
    var zPtr = Module._get_zbuf_ptr();
    console.log('[nanore] zPtr=' + zPtr);
    if (zPtr) {
      var buf = getMemoryBuffer();
      var zbuf = new Float32Array(buf, zPtr, W * H);
      var zmin = zbuf[0], zmax = zbuf[0];
      for (var i = 1; i < W * H; i++) {
        if (zbuf[i] < zmin) zmin = zbuf[i];
        if (zbuf[i] > zmax) zmax = zbuf[i];
      }
      var zrange = (zmax - zmin > 1e-6) ? (zmax - zmin) : 1;
      zbufImageData = ctx.createImageData(W, H);
      var zd = zbufImageData.data;
      for (var i = 0; i < W * H; i++) {
        var norm = (zbuf[i] - zmin) / zrange;
        var v = Math.round((1 - norm) * 255);
        if (v < 0) v = 0; if (v > 255) v = 255;
        zd[i * 4] = v;
        zd[i * 4 + 1] = v;
        zd[i * 4 + 2] = v;
        zd[i * 4 + 3] = 255;
      }
    }
  }

  function drawActiveTab() {
    var img = (activeTab === 'color') ? colorImageData : zbufImageData;
    if (img) {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.putImageData(img, 0, 0);
      console.log('[nanore] Drew ' + activeTab + ' ' + img.width + 'x' + img.height);
    }
  }

  // Tab switching
  var tabs = document.querySelectorAll('.tab');
  for (var i = 0; i < tabs.length; i++) {
    tabs[i].addEventListener('click', function() {
      document.querySelector('.tab.active').classList.remove('active');
      this.classList.add('active');
      activeTab = this.getAttribute('data-tab');
      drawActiveTab();
    });
  }

  // Debounced auto-render on edit
  editor.addEventListener('input', function() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(function() {
      startRender();
    }, 1000);
  });

  // Manual render button
  renderBtn.addEventListener('click', function() {
    clearTimeout(debounceTimer);
    startRender();
  });

  // Tab key support in textarea
  editor.addEventListener('keydown', function(e) {
    if (e.key === 'Tab') {
      e.preventDefault();
      var start = this.selectionStart;
      var end = this.selectionEnd;
      this.value = this.value.substring(0, start) + '  ' + this.value.substring(end);
      this.selectionStart = this.selectionEnd = start + 2;
    }
  });
})();
</script>
</body>
</html>
